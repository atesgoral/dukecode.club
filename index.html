<!DOCTYPE html>
<html lang="en">
<head>
  <meta enctype="UTF-8">
  <link rel="stylesheet" href="main.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/monokai-sublime.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body>
<header>
  <h1><a href="/">dukecode.club</a></h1>
</header>

<section>
  <h2>Week 6 - Dec 21, 2017</h2>
  <p class="snapshot">Here's where we've left off: <a href="https://jsfiddle.net/x75ut61o/154/">https://jsfiddle.net/x75ut61o/154/</a></p>
  <p>There's going to be so much stuff this week! Put on your seatbelts.</p>
  <p>So far we've been just drawing static images. Let's start a bit of animation. We'll draw animation frames using the <code>requestAnimationFrame</code> method. This method tells the browser to call your frame drawing function when the browser is ready to draw, typically 60 frames per second.</p>
  <p>First, some preperation. Instead of deleting code, you can "comment out" (or stash away) bits of your code. One way to do this in JavaScript is to add two forward slashes (<code>//</code>) to the left of the bits of code you want to comment out. Now go ahead and comment out the entire contents of our <code>handleMouseMove</code> function:</p>
  <pre><code class="js">function handleMouseMove(event) {
  //if (isMouseDown) {
    //drawSquare(event.clientX - 5, event.clientY - 5, 10, hsl(220, 100, 50));
  //}
}</code></pre>
  <p>So, we've stopped drawing a square immediately when the mouse moves. We'll store the mouse coordinates in two new variables and later use them in our animation. Add the following bits of code and also modify <code>handleMouseMove</code> to look like this:</p>
  <pre><code class="js">var mouseX = 0;
var mouseY = 0;

function handleMouseMove(event) {
  mouseX = event.clientX;
  mouseY = event.clientY;
  //if (isMouseDown) {
    //drawSquare(event.clientX - 5, event.clientY - 5, 10, hsl(220, 100, 50));
  //}
}</code></pre>
  <p>You can actually delete the commented-out bits of code. We'll never use them again. I just wanted to show you how you can comment out code.</p>
  <p>Now, we're storing the latest known coordinates of the mouse in the <code>mouseX</code> and <code>mouseY</code> variables.</p>
  <p>Let's add another utility function. We've drawing squares. Let's draw circles this week! Drawing a circle is actually a multi-step process and you'll appreciate hiding all those steps inside a single function. Add this:</p>
  <pre><code class="js">function drawCircle(x, y, radius, color) {
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, Math.PI * 2);
  ctx.fill();
}</code></pre>
  <p>Try it if you like!</p>
  <p>Now, we'll create a paint function and start using it for animation rendering. This part might look a bit tricky:</p>
  <pre><code class="js">function paint(t) {
  requestAnimationFrame(paint);

  ctx.fillStyle = 'black';
  ctx.fillRect(0, 0, c.width, c.height);

  drawCircle(mouseX, mouseY, 10, 'white');
}

requestAnimationFrame(paint);</code></pre>
  <p>Every frame, our paint function fills the entire canvas in black (erases the frame) and then draws a white circle at the last known coordinates of the mouse.</p>
  <p>Let's get a bit fancier. Here's a quick trick to make the white circle leave a trail behind. Instead of painting the canvas with a solid black, we'll fill it with a translucent black so that what's behind will show through and successive applications of the same translucent black will eventually turn older trails entirely black. This will make more sense when we see it in action. Change the <code>paint</code> function by adding the two <code>globalAlpha</code> lines to look like:</p>
  <pre><code class="js">function paint(t) {
  requestAnimationFrame(paint);

  ctx.globalAlpha = 0.1; // 10% opacity (very translucent!)
  ctx.fillStyle = 'black';
  ctx.fillRect(0, 0, c.width, c.height);
  ctx.globalAlpha = 1; // change back to fully opaque

  drawCircle(mouseX, mouseY, 10, 'white');
}

requestAnimationFrame(paint);</code></pre>
  <p>How about incorporating the mouse button into the mix? And some colours? I'll skip to the end without explaining every step of the way:</p>
  <pre><code class="js">function paint(t) {
  requestAnimationFrame(paint);

  ctx.fillStyle = 'black';
  ctx.globalAlpha = 0.1;
  ctx.fillRect(0, 0, c.width, c.height);
  ctx.globalAlpha = 1;

  if (isMouseDown) {
    drawCircle(mouseX, mouseY, 10, hsl(t % 360, 100, 50));
    drawCircle(c.width - mouseX, c.height - mouseY, 10, hsl(t % 360, 100, 50));
  } else {
    drawCircle(mouseX, mouseY, 10, 'white');
  }
}

requestAnimationFrame(paint);</code></pre>
  <p>I'll let you ponder about what's we've just added. But I'll explain what that <code>t</code> argument that our paint function receives. It's the time since the animation started (the first call to <code>requestAnimationFrame</code>. It keeps increasing at each frame. We can use the value of <code>t</code> to do time-based things in our animation. In our case, we're cycling the hue of the circle based on time.</p>
  <div class="experiments">
    Feel free to experiment:
    <ul>
      <li>Can you add more circles, using different cominations of <code>mouseX</code>, <code>mouseY</code>, <code>c.width</code> and <code>c.height</code> to create a <a href="https://en.wikipedia.org/wiki/Kaleidoscope">kaleidoscope</a>?</li>
    </ul>
  </div>
  <div class="references">
    References for the curious mind:
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/beginPath"><code>beginPath</code></a></li>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/arc"><code>arc</code></a></li>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fill"><code>fill</code></a></li>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalAlpha"><code>globalAlpha</code></a></li>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame"><code>requestAnimationFrame</code></a></li>
    </ul>
  </div>
  <p class="snapshot">Here's where we've gotten: <a href="https://jsfiddle.net/x75ut61o/155/">https://jsfiddle.net/x75ut61o/155/</a></p>
</section>

<section>
  <h2>Week 5 - Dec 14, 2017</h2>
  <p class="snapshot">Here's where we've left off: <a href="https://jsfiddle.net/x75ut61o/126/">https://jsfiddle.net/x75ut61o/126/</a></p>
  <p>We'll add some mouse interactivity! We'll cover a lot of ground this week, so use your time wisely!</p>
  <p>But, first let's give overselves a headstart and use some CSS (Cascading Style Sheets) + additional JavaScript to extend the canvas to fit the entire panel.</p>
  <p class="snapshot">Start with this fiddle: <a href="https://jsfiddle.net/x75ut61o/127/">https://jsfiddle.net/x75ut61o/127/</a></p>
  <p>CSS allows us to style HTML elements. This includes setting the dimensions of rectangular elements like the page body or a canvas element. Don't worry about CSS for now! But notice what we've added to grow our canvas to git the panel (or screen):</p>
  <p>The CSS:</p>
  <pre><code class="css">body, html {
  height: 100%;
}
body {
  margin: 0;
  padding: 0;
}
#c {
  width: 100%;
  height: 100%;
}</code></pre>
  <p>The JavaScript:</p>
  <pre><code class="js">c.width = c.offsetWidth;
c.height = c.offsetHeight;</code></pre>
  <p>Now that we have more space to play around with, let's respond to mouse movements!</p>
  <p>HTML elements "emit events" in response to user input like key presses, mouse movements, or mouse clicks. You can attach one or more event handlers to any HTML element you want.</p>
  <p>The event we'll look at now is the <code>mousemove</code> event which gets emitted by an HTML element when you move your mouse over it.</p>
  <p>First, remove the <code>for</code> loop that draws the diagonally arranged squares.</p>
  <p>Now, let's create a new function to handle the event and attach this function as an event handler on our canvas element:</p>
  <pre><code class="js">function handleMouseMove(event) {
  drawSquare(event.clientX - 5, event.clientY - 5, 10, hsl(220, 100, 50))
}

c.addEventListener('mousemove', handleMouseMove)</code></pre>
  <p>What if we wanted to make this work like a drawing application where you have to hold the mouse button down to draw?</p>
  <p>Two additional events that are interest to use are <code>mousedown</code> and <code>mouseup</code>.</p>
  <p><code>mousedown</code> gets emitted the moment you press a mouse button. No other mouse button events are emitted while you're still holding the mouse button down.</p>
  <p><code>mouseup</code> gets emitted the moment you let go of the mouse button that you've been pressing.</p>
  <p>We need to track the state of the mouse button (let's only worry about the left mouse button for now). We need to know if it's being held down.</p>
  <p>We can store the state of the mouse button in a new variable. Let's call it <code>isMouseDown</code>. When we run our program, since the mouse button will be intially "up", we can set the initial value of this variable to <code>false</code>:</p>
  <pre><code class="js">var isMouseDown = false;</code></pre>
  <p>Then let's add two new event handlers to toggle the value of this variable between <code>true</code> and <code>false</code>:</p>
  <pre><code class="js">function handleMouseDown(event) {
  isMouseDown = true;
}

function handleMouseUp(event) {
  isMouseDown = false;
}

c.addEventListener('mousedown', handleMouseDown)
c.addEventListener('mouseup', handleMouseUp)</code></pre>
  <p>And let's change our <code>mousemove</code> handler to check the value of <code>isMouseDown</code> and only draw if the mouse button is down:</p>
  <pre><code class="js">function handleMouseMove(event) {
  if (isMouseDown) {
    drawSquare(event.clientX - 5, event.clientY - 5, 10, hsl(220, 100, 50))
  }
}</code></pre>
  <p>The code block inside the <code>if</code> statement will only get executed if the condition (the part inside the parenthesis) is satisfied. This will get more evident after we start using a variety of <code>if</code> statements.</p>
  <div class="experiments">
    Feel free to experiment:
    <ul>
      <li>Change the size of the square based on the mouse coordinates or mouse button state.</li>
      <li>Make saturation and lightness dependent on the mouse coordinates or mouse button state.</li>
    </ul>
  </div>
  <div class="references">
    References for the curious mind:
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else">if</a></li>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/Events/mousedown">mousedown</a></li>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/Events/mouseup">mouseup</a></li>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/Events/mousemove">mousemove</a></li>
    </ul>
  </div>
  <p class="snapshot">Here's where we've gotten: <a href="https://jsfiddle.net/x75ut61o/129/">https://jsfiddle.net/x75ut61o/129/</a></p>
</section>

<section>
  <h2>Week 4 - Nov 30, 2017</h2>
  <p class="snapshot">Here's where we've left off: <a href="https://jsfiddle.net/x75ut61o/112/">https://jsfiddle.net/x75ut61o/112/</a></p>
  <p>We'll learn how to write our own functions.</p>
  <p>One of the uses of functions is to allow us to group a set of operations (or a single, complex operation) so that the entire group of actions can be performed with just a single call to a function.</p>
  <p>Take as an example how we draw a square: <code>ctx.fillRect(x, y, width, height)</code>. We could create a function to draw a square at a given (x, y) coordinate and size:</p>
  <pre><code class="js">function drawSquare(x, y, size) {
  ctx.fillRect(x, y, size, size)
}</code></pre>
  <p>This both reduced the number of arguments we have to use each time we have to draw a square (as opposed to repeating the same size for both the width and the height) and also communicates our intent better (i.e. "draw a square").</p>
  <p>Change the entire code to look like this:</p>
  <pre><code class="js">var ctx = c.getContext('2d')

function drawSquare(x, y, size) {
  ctx.fillRect(x, y, size, size)
}

for (var i = 0; i < 10; i++) {
  drawSquare(i * 10, i * 10, 10)
}</code></pre>
  <p>Functions will start getting more meaningful when we start doing more than just a single operation. Now, let's also specify the colour of the square by adding a color argument:</p>
<pre><code class="js">function drawSquare(x, y, size, color) {
  ctx.fillStyle = color;
  ctx.fillRect(x, y, size, size)
}</code></pre>
  <p>You can now call this function to draw a square with any colour: <code>drawSquare(10, 10, 20, 'red')</code>.</p>
  <p>Now, let's define a new function that allows us to define any colour we want, using hue, saturation and lightness (or luminosity)!</p>
<pre><code class="js">function hsl(hue, saturation, lightness) {
  return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
}</code></pre>
  <p>Now, change the entire code to look like this:</p>
  <pre><code class="js">var ctx = c.getContext('2d')

function drawSquare(x, y, size, color) {
  ctx.fillStyle = color;
  ctx.fillRect(x, y, size, size)
}

function hsl(hue, saturation, lightness) {
  return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
}

for (var i = 0; i < 10; i++) {
  drawSquare(i * 10, i * 10, 10, hsl(i * 36, 100, 50))
}</code></pre>
  <div class="experiments">
    Feel free to experiment:
    <ul>
      <li>Use different staturation and lightness values.</li>
      <li>Make saturation and lightness dependent on <code>i</code> as well.</li>
      <li>Hue is an angle between 0-360. What happens when you beyond 360? Can you guess?</li>
    </ul>
  </div>
  <div class="references">
    References for the curious mind:
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions">Functions</a></li>
      <li><a href="https://en.wikipedia.org/wiki/HSL_and_HSV">HSL and HSV</a></li>
    </ul>
  </div>
</section>

<section>
  <h2>Week 3 - Nov 23, 2017</h2>
  <p class="snapshot">Here's where we've left off: <a href="https://jsfiddle.net/x75ut61o/82/">https://jsfiddle.net/x75ut61o/82/</a></p>
  <p>We'll learn about the <code>for</code> loop!</p>
  <p>The <code>for</code> statement allows us to perform repetitive tasks by just writing code for a single step of the task, instead of typing lots and lots of code.</p>
  <p>The syntax might initially look ugly, but you'll get used to it over time. Here's a <code>for</code> loop setup that draws 10 squares in a diagonal pattern:</p>
  <pre><code class="js">var ctx = c.getContext('2d')

for (var i = 0; i < 10; i++) {
  ctx.fillRect(i * 10, i * 10, 10, 10)
}</code></pre>
  <p>To put what we're doing above in English:</p>
  <p>First define a new variable called <code>i</code> and set its initial value to 0 (<code>var i = 0</code>). And while <code>i</code> is less than 10 (<code>i < 10</code>), do what's inside this block (the part between the <code>{</code> and <code>}</code>) and then increment <code>i</code> by 1 (<code>i++</code>).</p>
  <p>What we're doing inside the block is drawing a square like we did before, but instead of using fixed values for the x and y coordinates, we're making x and y based on value of <code>i</code>.</p>
  <p>The loop starts with <code>i</code> set to 0. We compute both x and y as <code>i * 10</code>. So, on our first iteration, when <code>i</code> is 0, both x and y are 0. Remember, anything multipled by 0 is 0!</p>
  <p>On the second iteration, since we've incremented <code>i</code> by 1, the value of <code>i</code> is now 1. So both x and y are now 10.</p>
  <p>And so on...</p>
  <p>Until we hit the terminating/edge condition. This is when the value of <code>i</code> no longer satisfies "while <code>i</code> is less than 10". 9 is the last valid value for <code>i</code> that satisfies that condition. And when <code>i</code> hits the value of 10, we break out of the loop.</p>
  <p>So, the values that <code>i</code> in this example are: 0, 1, 2, 3, 4, 5, 6, 7, 8, and 9. The loop runs exactly 10 times.</p>
  <div class="experiments">
      Feel free to experiment:
      <ul>
        <li>Use different values instead of 10 to change the loop count. But, don't go too crazy (millions, billions) or you'll freeze the browser!</li>
        <li>Change the multipliers (<code>* 10</code>) you use.</li>
        <li>Use <code>i</code> in the width and height values.</li>
        <li>Use more interesting operations than just multiplication.</li>
      </ul>
  </div>
    <div class="references">
    References for the curious mind:
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for"><code>for</code></a></li>
    </ul>
  </div>
</section>

<section>
  <h2>Week 2 - Nov 9, 2017</h2>
  <p class="snapshot">Here's where we've left off: <a href="https://jsfiddle.net/x75ut61o/">https://jsfiddle.net/x75ut61o/</a></p>
  <p>We'll experiment with drawing different rectangles in different colours!</p>
  <p>The <code>fillStyle</code> property of the context object lets you change the fill color <em>before</em> filling a rectangle. It's like picking up a different crayon before painting a new rectangle.</p>
  <p>Copy and paste (or manually type from scratch) the <code>fillRect</code> line from last week to draw as many different rectangles at different positions and dimensions as you like. Set <code>fillStyle</code> to change the fill colour!</p>
  <pre><code class="js">var ctx = c.getContext('2d')

ctx.fillRect(0, 0, 10, 10)

ctx.fillStyle = 'red'
ctx.fillRect(20, 0, 10, 10)

ctx.fillStyle = 'blue'
ctx.fillRect(0, 20, 30, 10)</code></pre>
<div class="experiments">
    Feel free to experiment:
    <ul>
      <li>Use different colour values. Can you guess some colour names?</li>
      <li>Where can you find all the colour names you can use?</li>
      <li>Add more shapes with different colours to draw something.</li>
    </ul>
</div>
<div class="references">
    References for the curious mind:
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle"><code>fillStyle</code></a></li>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/color">Valid color values</a></li>
      <li><a href="https://en.wikipedia.org/wiki/Web_colors">Web colors</a></li>
    </ul>
  </div>
</section>

<section>
  <h2>Week 1 - Nov 2, 2017</h2>
  <p>Let's learn how to draw a simple square (or rectangle) using HTML and JavaScript, from scratch!</p>
  <p>
    Go to <a href="https://jsfiddle.net">JSFiddle</a> and enter the following in the HTML panel:
  </p>
  <pre><code class="html">&lt;canvas id="c"&gt;&lt;/canvas&gt;</code></pre>
  <p>And in the JavaScript panel, enter the following:</p>
  <pre><code class="js">var ctx = c.getContext('2d')

ctx.fillRect(0, 0, 10, 10)</code></pre>
  <p>After hitting <strong>Run</strong> you should see a black square in the output panel.</p>
  <p>We've created a canvas element, assigned it an id (identifier) of "c".
    The HTML we have is not a full-fledged, valid HTML, but it will do for now.</p>
  <p>We automatically get a <em>global</em> variable (more on that later) called <code>c</code> in JavaScript, which refers to our canvas element.
    This is a lazy way of doing this quickly, and not a best practice, but it will do for now.</p>
  <p>Then we get the 2D (two-dimensional) drawing context from the canvas element and store that in a new variable called <code>ctx</code>.</p>
  <p>Then we call the <code>fillRect()</code> method on the context to draw a rectangle. The arguments to the method are: x coordinate, y coordinate, width, height. In our case, we're drawing the rectangle at the top left corner of the canvas. It's 10 pixels by pixels, which make it a square.</p>
  <div class="experiments">
      Feel free to experiment:
      <ul>
        <li>Use different values for x, y, width and height.</li>
      </ul>
  </div>
  <div class="references">
    References for the curious mind:
    <ul>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext"><code>getContext()</code></a></li>
      <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillRect"><code>fillRect()</code></a></li>
    </ul>
  </div>
</section>

</body>
</html>
